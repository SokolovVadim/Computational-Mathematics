# Computational-Mathematics
Programming task in CM course in MIPT
# Task 1: LU-decomposition
Вам нужно запрограммировать решение системы линейных
уравнений с помощью LU-разложения.
и убедиться, что оно работает на приложенных матрицах.

Следующие уточнения:
* Программируйте на C/C++, Python или Octave/Matlab.
* Используйте тип вещественных чисел с двойной точностью.
* Программа должна считать квадратную матрицу А из файла.
   Первая строчка файла содержит размер n, потом матрица по строчкам.
   Два примера (файла) приложены.
* Вычислите множители L и U.
* Умножьте A на вектор x=(1, 2, ... n). Получится вектор b.
* Найдите решение используя множители L и U.
  Получится вектор y.
* Выведите на экран норму разницы между x и y.
* Все математические операции программируйте сами.
* Когда закончите и протестируете программу, пришлите её на этот
  адрес, переименовав исходник в 711_ivanov.cpp или тп.
* Работайте самостоятельно, программы проверяются на плагиат.

# Task 2: Successive over-relaxation algorithm
Программа должна считывать матрицу из файла (пример входного файла
приложен), выбрать какой-нибудь ненулевой вектор правой части и применить
ПВР к полученной системе, начиная с нулевого приближения. Параметр релаксации берите, например, 1.5.
ПВР должен применяться до достижения евклидовой нормы невязки 1е-6.
Норму невязки выводите на экран на каждой итерации

Потестируйте и сравните сходимость с методом Зейделя,
сделайте вывод, какой метод сходится быстрее (20 % оценки).

# Task 3: Newton's method on a System of Nonlinear Equations

Запрограммируйте метод Ньютона для решения системы нелинейных уравнений. На каждой
итерации метода не надо обращать матрицу Якоби явно, а потом её умножать на вектор невязки.
Вместо этого, решайте систему линейных алгебраических уравнений с этой матрицей. Для
системы линейных уравнений применяйте или библиотечную функцию, или свой алгоритм
факторизации из Компьютерного задания No1.
Выводите норму невязки и приближённое решение системы на каждой итерации метода
Ньютона. Продолжайте процесс до достижения нормы невязки 1е-6.
Продемонстрируйте его работу на следующей системе уравнений,
Au = exp(−u) ,
где u∈ R^n , A – симметричная положительно-определённая матрица n × n, экспонента от вектора
означает вектор со значениями равными экспоненте.

# Task 4: Simple pendulum vibration solution
Смоделируйте три периода свободных колебаний физического маятника с затуханием,
описываемого уравнением,  
``lu′′(t) + 2λu′(t) + g sin(u(t)) = 0``  
``u(0) = u0, u′(0) = v0.``  
Период приближённо можно считать равным
T = 2Pi sqrt(l/g)
При моделировании следует выполнять по 10-20 шагов по времени τ на период. Параметры l, λ,
g, u0 и v0. возьмите по своему усмотрению, но неравными нулю. Для расчётов используйте
явную схему Эйлера (EE) и схему Рунге-Кутты 4го порядка (RK).
Для малых колебаний вам хорошо известно точное решение (AN) из курса общей физики;
запрограммируйте его. Результаты выведите на экран в виде таблицы приближённых и точных
значений на каждом шаге.
Указание: для приближённого решения, преобразуйте дифференциальное уравнение второго
порядка к системе двух дифференциальных уравнений первого порядка.

# Task 5: Tridiagonal matrix algorithm

Напишите программу для приближённого решения краевой задачи,
−(g(x)y'(x))' + p(x)y(x) = f(x)
y'(0) = a,
методом конечных разностей, обеспечивая
y'(1) = b.
аппроксимацию 2го порядка.

Используйте
равномерную сетку из n интервалов. Храните в памяти не более трёх диагоналей матрицы. Для
решения системы используйте метод прогонки.

Протестируйте программу на случае, когда y(x) известная вам функция, но не полином,
коэффициенты p(x ) и g(x ) положительны и отделены от нуля. На основании y(x), p(x ) и g(x )
найдите аналитически f(x), a и b.

Для n = 20 выведите в столбик значения точного и найденного приближённого решения в узлах
сетки. Также выведите на экран кубическую (максимальную) норму разницы точного и
приближённого решения.

Приложите графики точного и приближённого решений в виде отдельного файла.
Указание: убедитесь, что норма ошибки имеет второй порядок малости, а графики близки.


# Build
``` bash
make
./run path_to_file
```
